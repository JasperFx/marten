<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="generator" content="Bootply" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Marten - Querying Documents with Linq</title>
    <link href="/marten/content/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <link href="/marten/content/prism.css" rel="stylesheet" type="text/css" />
    <link href="/marten/content/theme.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" />

    <link rel="apple-touch-icon" href="/bootstrap/img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/bootstrap/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/bootstrap/img/apple-touch-icon-114x114.png">

    <!-- CSS code from Bootply.com editor -->
    <link href="/marten/content/affix.css" rel="stylesheet" type="text/css" />
</head>

<!-- HTML code from Bootply.com editor -->

<body>
    <a href="https://github.com/jasperfx/marten"><img style="z-index: 5000; position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>

    <nav class="navbar navbar-default navbar-fixed-top" role="banner">
        <div class="container">
            <div class="navbar-header">
                <a href="/marten" class="navbar-brand">Marten 3.12.1</a>
            </div>
            <nav class="collapse navbar-collapse" role="navigation">
                <ul class="nav navbar-nav pull-right">
                    <li>
                        <a href="/marten/getting_started">Getting Started</a>
                    </li>
                    <li>
                        <a href="/marten/documentation">Documentation</a>
                    </li>
                    <li>
                        <a href="/marten/migration_guide">Migration Guide</a>
                    </li>
                    <li>
                        <a href="https://gitter.im/jasperfx/marten?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/jasperfx/marten" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a>
                    </li>
                    <li>
                        <a href="https://twitter.com/marten_lib?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @marten_lib</a>
                        <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
                    </li>
                    <li><a href="/marten/documentation/documents/querying" title="Querying Documents">Previous</a></li>
                <li><a href="/marten/documentation/documents/querying/async" title="Asynchronous Querying">Next</a></li>
                </ul>
                <div class="navbar-form navbar-left" role="search">
                    <div class="form-group">
                        <input id="search" type="search" class="form-control" placeholder="Search">
                    </div>
                </div>
            </nav>
        </div>
    </nav>
    <div class="container">
        <nav class="navbar-inverse">
            <ol class="breadcrumb"><li><a href="/marten/">Marten</a></li><li><a href="/marten/documentation">Documentation</a></li><li><a href="/marten/documentation/documents">Marten as Document Db</a></li><li><a href="/marten/documentation/documents/querying">Querying Documents</a></li><li class="active">Querying Documents with Linq</li></ol>
        </nav>
    </div>
    <!--main-->
    <div class="container">
        <div class="row">
            <!--left-->

            <div class="col-md-3" id="leftCol">

                <img src="/content/images/emblem.png" width="80%" align="middle" />
                <br />
                <ul class="nav nav-stacked affix" id="sidebar"></ul>
                <h3 class="no-margin">Next</h3><p><a href="/marten/documentation/documents/querying/async">Asynchronous Querying</a></p>
                    <h3 class="no-margin">Previous</h3><a href="/marten/documentation/documents/querying">Querying Documents</a></p>
                </ul>
            </div><!--/left-->
            <!--right-->
            <div class="col-md-9">
                <h1>Querying Documents with Linq <a href="https://github.com/jasperfx/marten/blob/master/documentation/documentation/documents/querying/linq.md" class="text-muted small pull-right fa fa-github" style="margin-top: 10px"> Edit on GitHub</a></h1>

                <hr />
                <div id="main-pane">
                    <!--Title:Querying Documents with Linq-->
<!--Url:linq-->
<p>Marten uses the <a href="https://github.com/re-motion/Relinq">Relinq library</a> to support a subset of the normal Linq operators. Linq queries are done with
Marten using the <code>IQuerySession.Query&lt;T&gt;()</code> or <code>IDocumentSession.Query&lt;T&gt;()</code> method to return an <a href="https://msdn.microsoft.com/en-us/library/system.linq.iqueryable(v=vs.100).aspx">IQueryable</a> for the document type <code>T</code>.</p>
<pre><code class="language-csharp">&#xD;&#xA;IMartenQueryable&lt;T&gt; Query&lt;T&gt;();&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>To query for all documents of a type - not that you would do this very often outside of testing - use the <code>Query&lt;T&gt;()</code> method like this:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void get_all_documents_of_a_type(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    // Calling ToArray() just forces the query to be executed&#xD;&#xA;    var targets = session.Query&lt;Target&gt;().ToArray();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="basic-operators">Basic Operators</h2>
<p>Since you usually don't want to pull down the entire database at one time, Marten supports these basic operators in Linq searches:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void basic_operators(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    // Field equals a value&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number == 5);&#xD;&#xA;&#xD;&#xA;    // Field does not equal a value&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number != 5);&#xD;&#xA;&#xD;&#xA;    // Field compared to values&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number &gt; 5);&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number &gt;= 5);&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number &lt; 5);&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number &lt;= 5);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="and-and-or-queries">And and Or Queries</h2>
<p>Right now, Marten supports both <em>and</em> and <em>or</em> queries with Linq:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void and_or(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    // AND queries&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number &gt; 0 &amp;&amp; x.Number &lt;= 5);&#xD;&#xA;&#xD;&#xA;    // OR queries&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number == 5 || x.Date == DateTime.Today);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="searching-within-child-collections">Searching within Child Collections</h2>
<p>As of v0.7, Marten supports simple <code>Any()</code> queries within child collections, <strong>but only for checking
equality</strong> of members of the child collection elements (this feature uses the <a href="http://www.postgresql.org/docs/9.5/static/datatype-json.html">Postgresql JSONB containment operator</a> to compose the underlying SQL).</p>
<p>Marten will also allow you to use the <code>Contains</code> method to search within arrays or lists of simple elements like strings.</p>
<p>The following code sample demonstrates the supported Linq patterns for collection searching:</p>
<pre><code class="language-csharp">&#xD;&#xA;public class ClassWithChildCollections&#xD;&#xA;{&#xD;&#xA;    public Guid Id;&#xD;&#xA;&#xD;&#xA;    public IList&lt;User&gt; Users = new List&lt;User&gt;();&#xD;&#xA;    public Company[] Companies = new Company[0];&#xD;&#xA;&#xD;&#xA;    public string[] Names;&#xD;&#xA;    public IList&lt;string&gt; NameList;&#xD;&#xA;    public List&lt;string&gt; NameList2;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public void searching(IDocumentStore store)&#xD;&#xA;{&#xD;&#xA;    using (var session = store.QuerySession())&#xD;&#xA;    {&#xD;&#xA;        var searchNames = new string[] { &quot;Ben&quot;, &quot;Luke&quot; };&#xD;&#xA;&#xD;&#xA;        session.Query&lt;ClassWithChildCollections&gt;()&#xD;&#xA;            // Where collections of deep objects&#xD;&#xA;            .Where(x =&gt; x.Companies.Any(_ =&gt; _.Name == &quot;Jeremy&quot;))&#xD;&#xA;&#xD;&#xA;            // Where for Contains() on array of simple types&#xD;&#xA;            .Where(x =&gt; x.Names.Contains(&quot;Corey&quot;))&#xD;&#xA;&#xD;&#xA;            // Where for Contains() on List&lt;T&gt; of simple types&#xD;&#xA;            .Where(x =&gt; x.NameList.Contains(&quot;Phillip&quot;))&#xD;&#xA;&#xD;&#xA;            // Where for Contains() on IList&lt;T&gt; of simple types&#xD;&#xA;            .Where(x =&gt; x.NameList2.Contains(&quot;Jens&quot;))&#xD;&#xA;&#xD;&#xA;            // Where for Any(element == value) on simple types&#xD;&#xA;            .Where(x =&gt; x.Names.Any(_ =&gt; _ == &quot;Phillip&quot;))&#xD;&#xA;&#xD;&#xA;            // The Contains() operator on subqueries within Any() searches&#xD;&#xA;            // only supports constant array of String or Guid expressions.&#xD;&#xA;            // Both the property being searched (Names) and the values&#xD;&#xA;            // being compared (searchNames) need to be arrays.&#xD;&#xA;            .Where(x =&gt; x.Names.Any(_ =&gt; searchNames.Contains(_)));&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>You can search on equality of multiple fields or properties within the child collection
using the <code>&amp;&amp;</code> operator:</p>
<pre><code class="language-csharp">&#xD;&#xA;var results = theSession&#xD;&#xA;    .Query&lt;Target&gt;()&#xD;&#xA;    .Where(x =&gt; x.Children.Any(_ =&gt; _.Number == 6 &amp;&amp; _.Double == -1))&#xD;&#xA;    .ToArray();&#xD;&#xA;</code></pre>
<p>Finally, you can query for child collections that do <strong>not</strong> contain a value:</p>
<pre><code class="language-csharp">&#xD;&#xA;theSession.Query&lt;DocWithArrays&gt;().Count(x =&gt; !x.Strings.Contains(&quot;c&quot;))&#xD;&#xA;    .ShouldBe(2);&#xD;&#xA;</code></pre>
<h2 id="searching-for-null-values">Searching for NULL Values</h2>
<p>Regardless of your feelings about <em>NULL</em>, they do exist in databases and Marten allows you to search for documents that have (or don't have) null values:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void query_by_nullable_type_nulls(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    // You can use Nullable&lt;T&gt;.HasValue in Linq queries&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; !x.NullableNumber.HasValue).ToArray();&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.NullableNumber.HasValue).ToArray();&#xD;&#xA;&#xD;&#xA;    // You can always search by field is NULL&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Inner == null);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="deep-queries">Deep Queries</h2>
<p>Marten's Linq support will allow you to make &quot;deep&quot; searches on properties of properties (or fields):</p>
<pre><code class="language-csharp">&#xD;&#xA;public void deep_queries(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Inner.Number == 3);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="searching-on-string-fields">Searching on String Fields</h2>
<p>Marten supports a subset of the common sub/string searches:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void string_fields(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.String.StartsWith(&quot;A&quot;));&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.String.EndsWith(&quot;Suffix&quot;));&#xD;&#xA;&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.String.Contains(&quot;something&quot;));&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.String.Equals(&quot;The same thing&quot;));&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>Marten also supports case insensitive substring searches:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void case_insensitive_string_fields(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.String.StartsWith(&quot;A&quot;, StringComparison.OrdinalIgnoreCase));&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.String.EndsWith(&quot;SuFfiX&quot;, StringComparison.OrdinalIgnoreCase));&#xD;&#xA;&#xD;&#xA;    // using Marten.Util&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.String.Contains(&quot;soMeThiNg&quot;, StringComparison.OrdinalIgnoreCase));&#xD;&#xA;&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.String.Equals(&quot;ThE SaMe ThInG&quot;, StringComparison.OrdinalIgnoreCase));&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>A shorthand for case-insensitive string matching is provided through <code>EqualsIgnoreCase</code> (string extension method in <em>Baseline</em>):</p>
<pre><code class="language-csharp">&#xD;&#xA;query.Query&lt;User&gt;().Single(x =&gt; x.UserName.EqualsIgnoreCase(&quot;abc&quot;)).Id.ShouldBe(user1.Id);&#xD;&#xA;query.Query&lt;User&gt;().Single(x =&gt; x.UserName.EqualsIgnoreCase(&quot;aBc&quot;)).Id.ShouldBe(user1.Id);&#xD;&#xA;</code></pre>
<p>This defaults to <code>String.Equals</code> with <code>StringComparison.CurrentCultureIgnoreCase</code> as comparison type.</p>
<h2 id="count">Count()</h2>
<p>Marten supports the <code>IQueryable.Count()</code> method:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void count_with_a_where_clause()&#xD;&#xA;{&#xD;&#xA;    // theSession is an IDocumentSession in this test&#xD;&#xA;    theSession.Store(new Target { Number = 1 });&#xD;&#xA;    theSession.Store(new Target { Number = 2 });&#xD;&#xA;    theSession.Store(new Target { Number = 3 });&#xD;&#xA;    theSession.Store(new Target { Number = 4 });&#xD;&#xA;    theSession.Store(new Target { Number = 5 });&#xD;&#xA;    theSession.Store(new Target { Number = 6 });&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;&#xD;&#xA;    theSession.Query&lt;Target&gt;().Count(x =&gt; x.Number &gt; 3).ShouldBe(3);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="min">Min()</h2>
<p>Marten supports the <code>IQueryable.Min()</code> method:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void get_min()&#xD;&#xA;{&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Blue, Number = 1 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Red, Number = 2 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Green, Number = -5 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Blue, Number = 42 });&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;    var minNumber = theSession.Query&lt;Target&gt;().Min(t =&gt; t.Number);&#xD;&#xA;    minNumber.ShouldBe(-5);&#xD;&#xA;}&#xD;&#xA;</code></pre>
<h2 id="max">Max()</h2>
<p>Marten supports the <code>IQueryable.Max()</code> method:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void get_max()&#xD;&#xA;{&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Blue, Number = 1 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Red, Number = 42 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Green, Number = 3 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Blue, Number = 4 });&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;    var maxNumber = theSession.Query&lt;Target&gt;().Max(t =&gt; t.Number);&#xD;&#xA;    maxNumber.ShouldBe(42);&#xD;&#xA;}&#xD;&#xA;</code></pre>
<h2 id="average">Average()</h2>
<p>Marten supports the <code>IQueryable.Average()</code> method:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void get_average()&#xD;&#xA;{&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Blue, Number = 1 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Red, Number = 2 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Green, Number = -5 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Blue, Number = 42 });&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;    var average = theSession.Query&lt;Target&gt;().Average(t =&gt; t.Number);&#xD;&#xA;    average.ShouldBe(10);&#xD;&#xA;}&#xD;&#xA;</code></pre>
<h2 id="sum">Sum()</h2>
<p>Marten supports the <code>IQueryable.Sum()</code> method:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void get_sum_of_integers()&#xD;&#xA;{&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Blue, Number = 1 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Red, Number = 2 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Green, Number = 3 });&#xD;&#xA;    theSession.Store(new Target { Color = Colors.Blue, Number = 4 });&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;    theSession.Query&lt;Target&gt;().Sum(x =&gt; x.Number)&#xD;&#xA;        .ShouldBe(10);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="ordering-results">Ordering Results</h2>
<p>Marten contains support for expressing ordering in both ascending and descending order in Linq queries:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void order_by(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    // Sort in ascending order&#xD;&#xA;    session.Query&lt;Target&gt;().OrderBy(x =&gt; x.Date);&#xD;&#xA;&#xD;&#xA;    // Sort in descending order&#xD;&#xA;    session.Query&lt;Target&gt;().OrderByDescending(x =&gt; x.Date);&#xD;&#xA;&#xD;&#xA;    // You can use multiple order by&#x27;s&#xD;&#xA;    session.Query&lt;Target&gt;().OrderBy(x =&gt; x.Date).ThenBy(x =&gt; x.Number);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="take-and-skip-for-paging">Take() and Skip() for Paging</h2>
<p>For simple paging, Marten supports the <code>IQueryable.Take()</code> and <code>IQueryable.Skip()</code> methods:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void using_take_and_skip(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    // gets records 11-20 from the database&#xD;&#xA;    session.Query&lt;Target&gt;().Skip(10).Take(10).OrderBy(x =&gt; x.Number).ToArray();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="searching-for-a-single-document">Searching for a Single Document</h2>
<p>Marten supports the <code>IQueryable</code> methods for returning only a single document at a time:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void select_a_single_value(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    // Single()/SingleOrDefault() will throw exceptions if more than&#xD;&#xA;    // one result is returned from the database&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number == 5).Single();&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number == 5).SingleOrDefault();&#xD;&#xA;&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number == 5).OrderBy(x =&gt; x.Date).First();&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number == 5).OrderBy(x =&gt; x.Date).FirstOrDefault();&#xD;&#xA;&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number == 5).OrderBy(x =&gt; x.Date).Last();&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Number == 5).OrderBy(x =&gt; x.Date).LastOrDefault();&#xD;&#xA;&#xD;&#xA;    // Using the query inside of Single/Last/First is supported as well&#xD;&#xA;    session.Query&lt;Target&gt;().Single(x =&gt; x.Number == 5);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="querying-within-value-ienumerables">Querying within Value IEnumerables</h2>
<p>As of now, Marten allows you to do &quot;contains&quot; searches within Arrays, Lists &amp; ILists of primitive values like string or numbers:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void query_against_string_array()&#xD;&#xA;{&#xD;&#xA;    var doc1 = new DocWithArrays { Strings = new string[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } };&#xD;&#xA;    var doc2 = new DocWithArrays { Strings = new string[] { &quot;c&quot;, &quot;d&quot;, &quot;e&quot; } };&#xD;&#xA;    var doc3 = new DocWithArrays { Strings = new string[] { &quot;d&quot;, &quot;e&quot;, &quot;f&quot; } };&#xD;&#xA;&#xD;&#xA;    theSession.Store(doc1);&#xD;&#xA;    theSession.Store(doc2);&#xD;&#xA;    theSession.Store(doc3);&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;&#xD;&#xA;    theSession.Query&lt;DocWithArrays&gt;().Where(x =&gt; x.Strings.Contains(&quot;c&quot;)).ToArray()&#xD;&#xA;        .Select(x =&gt; x.Id).ShouldHaveTheSameElementsAs(doc1.Id, doc2.Id);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>Marten also allows you to query over IEnumerables using the Any method for equality (similar to Contains):</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void query_against_number_list_with_any()&#xD;&#xA;{&#xD;&#xA;    var doc1 = new DocWithLists { Numbers = new List&lt;int&gt; { 1, 2, 3 } };&#xD;&#xA;    var doc2 = new DocWithLists { Numbers = new List&lt;int&gt; { 3, 4, 5 } };&#xD;&#xA;    var doc3 = new DocWithLists { Numbers = new List&lt;int&gt; { 5, 6, 7 } };&#xD;&#xA;    var doc4 = new DocWithLists { Numbers = new List&lt;int&gt; { } };&#xD;&#xA;&#xD;&#xA;    theSession.Store(doc1, doc2, doc3, doc4);&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;&#xD;&#xA;    theSession.Query&lt;DocWithLists&gt;().Where(x =&gt; x.Numbers.Any(_ =&gt; _ == 3)).ToArray()&#xD;&#xA;        .Select(x =&gt; x.Id).ShouldHaveTheSameElementsAs(doc1.Id, doc2.Id);&#xD;&#xA;&#xD;&#xA;    // Or without any predicate&#xD;&#xA;    theSession.Query&lt;DocWithLists&gt;()&#xD;&#xA;        .Count(x =&gt; x.Numbers.Any()).ShouldBe(3);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>As of 1.2, you can also query against the <code>Count()</code> or <code>Length</code> of a child collection with the normal comparison
operators (<code>==</code>, <code>&gt;</code>, <code>&gt;=</code>, etc.):</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void query_against_number_list_with_count_method()&#xD;&#xA;{&#xD;&#xA;    var doc1 = new DocWithLists { Numbers = new List&lt;int&gt; { 1, 2, 3 } };&#xD;&#xA;    var doc2 = new DocWithLists { Numbers = new List&lt;int&gt; { 3, 4, 5 } };&#xD;&#xA;    var doc3 = new DocWithLists { Numbers = new List&lt;int&gt; { 5, 6, 7, 8 } };&#xD;&#xA;&#xD;&#xA;    theSession.Store(doc1);&#xD;&#xA;    theSession.Store(doc2);&#xD;&#xA;    theSession.Store(doc3);&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;&#xD;&#xA;    theSession.Query&lt;DocWithLists&gt;()&#xD;&#xA;        .Single(x =&gt; x.Numbers.Count() == 4).Id.ShouldBe(doc3.Id);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="selectmany">SelectMany()</h2>
<p>Marten 1.2 adds the ability to use the <code>SelectMany()</code> operator to issue queries against child collections. You can use
<code>SelectMany()</code> against primitive collections like so:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void can_do_simple_select_many_against_simple_array()&#xD;&#xA;{&#xD;&#xA;    var product1 = new Product {Tags = new[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}};&#xD;&#xA;    var product2 = new Product {Tags = new[] {&quot;b&quot;, &quot;c&quot;, &quot;d&quot;}};&#xD;&#xA;    var product3 = new Product {Tags = new[] {&quot;d&quot;, &quot;e&quot;, &quot;f&quot;}};&#xD;&#xA;&#xD;&#xA;    using (var session = theStore.OpenSession())&#xD;&#xA;    {&#xD;&#xA;        session.Store(product1, product2, product3);&#xD;&#xA;        session.SaveChanges();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    using (var query = theStore.QuerySession())&#xD;&#xA;    {&#xD;&#xA;        var distinct = query.Query&lt;Product&gt;().SelectMany(x =&gt; x.Tags).Distinct().ToList();&#xD;&#xA;&#xD;&#xA;        distinct.OrderBy(x =&gt; x).ShouldHaveTheSameElementsAs(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;);&#xD;&#xA;&#xD;&#xA;        var names = query.Query&lt;Product&gt;().SelectMany(x =&gt; x.Tags).ToList();&#xD;&#xA;        names&#xD;&#xA;            .Count().ShouldBe(9);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;</code></pre>
<p>Or against collections of child documents:</p>
<pre><code class="language-csharp">&#xD;&#xA;var results = query.Query&lt;Target&gt;()&#xD;&#xA;    .SelectMany(x =&gt; x.Children)&#xD;&#xA;    .Where(x =&gt; x.Flag)&#xD;&#xA;    .OrderBy(x =&gt; x.Id)&#xD;&#xA;    .Skip(20)&#xD;&#xA;    .Take(15)&#xD;&#xA;    .ToList();&#xD;&#xA;</code></pre>
<p>A few notes on the <code>SelectMany()</code> usage and limitations:</p>
<ul>
<li>As of 1.2, you are only able to use a single <code>SelectMany()</code> operator in a single Linq query. That limitation will be removed in 1.3.</li>
<li>You can use any other Linq operator that Marten supports <em>after</em> the <code>SelectMany()</code> in a Linq query, including the <code>Stats()</code> and <code>Include()</code> operators</li>
<li><code>Take()</code> and <code>Skip()</code> operators in a Linq query that contains a <code>SelectMany()</code> operator will always apply to the child collection database
rather than the parent document regardless of the order in which the operators appear in the Linq query</li>
<li>You cannot use <code>SelectMany()</code> with both a <code>Distinct()</code> and a <code>Count()</code> operator at this point.</li>
</ul>
<h2 id="distinct">Distinct()</h2>
<p>New in Marten 1.2 is support for the Linq <code>Distinct()</code> operator:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void get_distinct_string()&#xD;&#xA;{&#xD;&#xA;    theSession.Store(new Target {String = &quot;one&quot;});&#xD;&#xA;    theSession.Store(new Target {String = &quot;one&quot;});&#xD;&#xA;    theSession.Store(new Target {String = &quot;two&quot;});&#xD;&#xA;    theSession.Store(new Target {String = &quot;two&quot;});&#xD;&#xA;    theSession.Store(new Target {String = &quot;three&quot;});&#xD;&#xA;    theSession.Store(new Target {String = &quot;three&quot;});&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;&#xD;&#xA;    var queryable = theSession.Query&lt;Target&gt;().Select(x =&gt; x.String).Distinct();&#xD;&#xA;&#xD;&#xA;    queryable.ToList().Count.ShouldBe(3);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>Do note that the <code>Distinct()</code> keyword can be used with <code>Select()</code> transforms as well:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void get_distinct_numbers()&#xD;&#xA;{&#xD;&#xA;    theSession.Store(new Target {Number = 1, Decimal = 1.0M});&#xD;&#xA;    theSession.Store(new Target {Number = 1, Decimal = 2.0M});&#xD;&#xA;    theSession.Store(new Target {Number = 1, Decimal = 2.0M});&#xD;&#xA;    theSession.Store(new Target {Number = 2, Decimal = 1.0M});&#xD;&#xA;    theSession.Store(new Target {Number = 2, Decimal = 2.0M});&#xD;&#xA;    theSession.Store(new Target {Number = 2, Decimal = 1.0M});&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;&#xD;&#xA;    var queryable = theSession.Query&lt;Target&gt;().Select(x =&gt; new&#xD;&#xA;    {&#xD;&#xA;        x.Number,&#xD;&#xA;        x.Decimal&#xD;&#xA;    }).Distinct();&#xD;&#xA;&#xD;&#xA;    queryable.ToList().Count.ShouldBe(4);&#xD;&#xA;}&#xD;&#xA;</code></pre>
<h2 id="searching-with-boolean-flags">Searching with Boolean Flags</h2>
<p>Linq queries against boolean properties can use shorthand mechanisms in <code>Where()</code> clauses like so:</p>
<pre><code class="language-csharp">&#xD;&#xA;public void query_by_booleans(IDocumentSession session)&#xD;&#xA;{&#xD;&#xA;    // Flag is a boolean property.&#xD;&#xA;&#xD;&#xA;    // Where Flag is true&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Flag).ToArray();&#xD;&#xA;    // or&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Flag == true).ToArray();&#xD;&#xA;&#xD;&#xA;    // Where Flag is false&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; !x.Flag).ToArray();&#xD;&#xA;    // or&#xD;&#xA;    session.Query&lt;Target&gt;().Where(x =&gt; x.Flag == false).ToArray();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="use-matchessqlsql-to-search-using-raw-sql">Use MatchesSql(sql) to search using raw SQL</h2>
<p>Combine your Linq queries with raw SQL using the <code>MatchesSql(sql)</code> method like so:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void query_with_matches_sql()&#xD;&#xA;{&#xD;&#xA;    using (var session = theStore.OpenSession())&#xD;&#xA;    {&#xD;&#xA;        var u = new User { FirstName = &quot;Eric&quot;, LastName = &quot;Smith&quot; };&#xD;&#xA;        session.Store(u);&#xD;&#xA;        session.SaveChanges();&#xD;&#xA;&#xD;&#xA;        var user = session.Query&lt;User&gt;().Where(x =&gt; x.MatchesSql(&quot;data-&gt;&gt; &#x27;FirstName&#x27; = ?&quot;, &quot;Eric&quot;)).Single();&#xD;&#xA;        user.LastName.ShouldBe(&quot;Smith&quot;);&#xD;&#xA;        user.Id.ShouldBe(u.Id);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;</code></pre>
<h2 id="isoneof">IsOneOf</h2>
<p><code>IsOneOf()</code> extension can be used to query for documents having
a field or property matching one of many supplied values:</p>
<pre><code class="language-csharp">&#xD;&#xA;// Finds all SuperUser&#x27;s whose role is either&#xD;&#xA;// Admin, Supervisor, or Director&#xD;&#xA;var users = session.Query&lt;SuperUser&gt;()&#xD;&#xA;    .Where(x =&gt; x.Role.IsOneOf(&quot;Admin&quot;, &quot;Supervisor&quot;, &quot;Director&quot;));&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>To find one of for an array you can use this strategy:</p>
<pre><code class="language-csharp">&#xD;&#xA;// Finds all UserWithNicknames&#x27;s whose nicknames matches either &quot;Melinder&quot; or &quot;Norrland&quot;&#xD;&#xA;&#xD;&#xA;var nickNames = new[] {&quot;Melinder&quot;, &quot;Norrland&quot;};&#xD;&#xA;&#xD;&#xA;var users = session.Query&lt;UserWithNicknames&gt;()&#xD;&#xA;    .Where(x =&gt; x.Nicknames.IsOneOf(nickNames));&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>To find one of for a list you can use this strategy:</p>
<pre><code class="language-csharp">&#xD;&#xA;// Finds all SuperUser&#x27;s whose role is either&#xD;&#xA;// Admin, Supervisor, or Director&#xD;&#xA;var listOfRoles = new List&lt;string&gt; {&quot;Admin&quot;, &quot;Supervisor&quot;, &quot;Director&quot;};&#xD;&#xA;&#xD;&#xA;var users = session.Query&lt;SuperUser&gt;()&#xD;&#xA;    .Where(x =&gt; x.Role.IsOneOf(listOfRoles));&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="in">In</h2>
<p><code>In()</code> extension works exactly the same as <code>IsOneOf()</code>. It was introduced as syntactic sugar to ease RavenDB transition:</p>
<pre><code class="language-csharp">&#xD;&#xA;// Finds all SuperUser&#x27;s whose role is either&#xD;&#xA;// Admin, Supervisor, or Director&#xD;&#xA;var users = session.Query&lt;SuperUser&gt;()&#xD;&#xA;    .Where(x =&gt; x.Role.In(&quot;Admin&quot;, &quot;Supervisor&quot;, &quot;Director&quot;));&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>To find one of for an array you can use this strategy:</p>
<pre><code class="language-csharp">&#xD;&#xA;// Finds all UserWithNicknames&#x27;s whose nicknames matches either &quot;Melinder&quot; or &quot;Norrland&quot;&#xD;&#xA;&#xD;&#xA;var nickNames = new[] {&quot;Melinder&quot;, &quot;Norrland&quot;};&#xD;&#xA;&#xD;&#xA;var users = session.Query&lt;UserWithNicknames&gt;()&#xD;&#xA;    .Where(x =&gt; x.Nicknames.In(nickNames));&#xD;&#xA;&#xD;&#xA;</code></pre>
<p>To find one of for a list you can use this strategy:</p>
<pre><code class="language-csharp">&#xD;&#xA;// Finds all SuperUser&#x27;s whose role is either&#xD;&#xA;// Admin, Supervisor, or Director&#xD;&#xA;var listOfRoles = new List&lt;string&gt; {&quot;Admin&quot;, &quot;Supervisor&quot;, &quot;Director&quot;};&#xD;&#xA;&#xD;&#xA;var users = session.Query&lt;SuperUser&gt;()&#xD;&#xA;    .Where(x =&gt; x.Role.In(listOfRoles));&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="issupersetof">IsSupersetOf</h2>
<pre><code class="language-csharp">&#xD;&#xA;// Finds all Posts whose Tags is superset of&#xD;&#xA;// c#, json, or postgres&#xD;&#xA;var posts = theSession.Query&lt;Post&gt;()&#xD;&#xA;    .Where(x =&gt; x.Tags.IsSupersetOf(&quot;c#&quot;, &quot;json&quot;, &quot;postgres&quot;));&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="issubsetof">IsSubsetOf</h2>
<pre><code class="language-csharp">&#xD;&#xA;// Finds all Posts whose Tags is subset of&#xD;&#xA;// c#, json, or postgres&#xD;&#xA;var posts = theSession.Query&lt;Post&gt;()&#xD;&#xA;    .Where(x =&gt; x.Tags.IsSubsetOf(&quot;c#&quot;, &quot;json&quot;, &quot;postgres&quot;));&#xD;&#xA;&#xD;&#xA;</code></pre>
<h2 id="modulo-queries">Modulo Queries</h2>
<p>Marten has the ability to use the modulo operator in Linq queries:</p>
<pre><code class="language-csharp">&#xD;&#xA;[Fact]&#xD;&#xA;public void use_modulo()&#xD;&#xA;{&#xD;&#xA;    theSession.Store(new Target{Color = Colors.Blue, Number = 1});&#xD;&#xA;    theSession.Store(new Target{Color = Colors.Blue, Number = 2});&#xD;&#xA;    theSession.Store(new Target{Color = Colors.Blue, Number = 3});&#xD;&#xA;    theSession.Store(new Target{Color = Colors.Blue, Number = 4});&#xD;&#xA;    theSession.Store(new Target{Color = Colors.Blue, Number = 5});&#xD;&#xA;    theSession.Store(new Target{Color = Colors.Green, Number = 6});&#xD;&#xA;&#xD;&#xA;    theSession.SaveChanges();&#xD;&#xA;&#xD;&#xA;    theSession.Query&lt;Target&gt;().Where(x =&gt; x.Number % 2 == 0 &amp;&amp; x.Color &lt; Colors.Green).ToArray()&#xD;&#xA;        .Select(x =&gt; x.Number)&#xD;&#xA;        .ShouldHaveTheSameElementsAs(2, 4);&#xD;&#xA;}&#xD;&#xA;</code></pre>
<h2 id="anytenant">AnyTenant</h2>
<p>Query data from all tenants using <code>AnyTenant</code> method.</p>
<pre><code class="language-csharp">&#xD;&#xA;// query data across all tenants&#xD;&#xA;var actual = query.Query&lt;Target&gt;().Where(x =&gt; x.AnyTenant() &amp;&amp; x.Flag)&#xD;&#xA;                  .OrderBy(x =&gt; x.Id).Select(x =&gt; x.Id).ToArray();&#xD;&#xA;</code></pre>
<h2 id="tenantisoneof">TenantIsOneOf</h2>
<p>Use <code>TenantIsOneOf</code> to query on a selected list of tenants.</p>
<pre><code class="language-csharp">&#xD;&#xA;// query data for a selected list of tenants&#xD;&#xA;var actual = query.Query&lt;Target&gt;().Where(x =&gt; x.TenantIsOneOf(&quot;Green&quot;, &quot;Red&quot;) &amp;&amp; x.Flag)&#xD;&#xA;                  .OrderBy(x =&gt; x.Id).Select(x =&gt; x.Id).ToArray();&#xD;&#xA;</code></pre>
<h2 id="text-search">Text Search</h2>
<p>Postgres contains built in <a href="https://www.postgresql.org/docs/10/textsearch-controls.html">Text Search functions</a>. They enable the possibility to do more sophisticated searching through text fields. Marten gives possibility to define <a href="/marten/documentation/documents/customizing/full_text">Full Text Indexes</a> and perform queries on them.
Currently three types of full Text Search functions are supported:</p>
<ul>
<li>regular Search (to_tsquery)</li>
</ul>
<pre><code class="language-csharp">&#xD;&#xA;var posts = session.Query&lt;BlogPost&gt;()&#xD;&#xA;    .Where(x =&gt; x.Search(&quot;somefilter&quot;))&#xD;&#xA;    .ToList();&#xD;&#xA;</code></pre>
<ul>
<li>plain text Search (plainto_tsquery)</li>
</ul>
<pre><code class="language-csharp">&#xD;&#xA;var posts = session.Query&lt;BlogPost&gt;()&#xD;&#xA;    .Where(x =&gt; x.PlainTextSearch(&quot;somefilter&quot;))&#xD;&#xA;    .ToList();&#xD;&#xA;</code></pre>
<ul>
<li>phrase Search (phraseto_tsquery)</li>
</ul>
<pre><code class="language-csharp">&#xD;&#xA;var posts = session.Query&lt;BlogPost&gt;()&#xD;&#xA;    .Where(x =&gt; x.PhraseSearch(&quot;somefilter&quot;))&#xD;&#xA;    .ToList();&#xD;&#xA;</code></pre>
<ul>
<li>web-style Search (websearch_to_tsquery, <a href="https://www.postgresql.org/docs/11/textsearch-controls.html">supported from Postgres 11+</a>)</li>
</ul>
<pre><code class="language-csharp">&#xD;&#xA;var posts = session.Query&lt;BlogPost&gt;()&#xD;&#xA;    .Where(x =&gt; x.WebStyleSearch(&quot;somefilter&quot;))&#xD;&#xA;    .ToList();&#xD;&#xA;</code></pre>
<p>All types of Text Searches can be combined with other Linq queries</p>
<pre><code class="language-csharp">&#xD;&#xA;var posts = session.Query&lt;BlogPost&gt;()&#xD;&#xA;    .Where(x =&gt; x.Category == &quot;LifeStyle&quot;)&#xD;&#xA;    .Where(x =&gt; x.PhraseSearch(&quot;somefilter&quot;))&#xD;&#xA;    .ToList();&#xD;&#xA;</code></pre>
<p>They allow also to specify language (regConfig) of the text search query (by default <code>english</code> is being used)</p>
<pre><code class="language-csharp">&#xD;&#xA;var posts = session.Query&lt;BlogPost&gt;()&#xD;&#xA;    .Where(x =&gt; x.PhraseSearch(&quot;somefilter&quot;, &quot;italian&quot;))&#xD;&#xA;    .ToList();&#xD;&#xA;</code></pre>
<h2 id="supported-types">Supported Types</h2>
<p>At this point, Marten's Linq support has been tested against these .Net types:</p>
<ol>
<li>String</li>
<li>Int32 &amp; Int64 (int and long)</li>
<li>Decimal (float)</li>
<li>DateTime and DateTimeOffset</li>
<li>Enum values</li>
<li>Nullable<T> of all of the above types</li>
<li>Booleans</li>
</ol>

                </div>
                <hr />
                <nav class="related-links">
                    <span>
                        <strong>Previous: </strong><a href="/marten/documentation/documents/querying">Querying Documents</a>
                    </span>
                    <span class="pull-right">
                        <strong>Next: </strong><a href="/marten/documentation/documents/querying/async">Asynchronous Querying</a>
                    </span>
                </nav>
            </div><!--/right-->
        </div><!--/row-->
    </div><!--/container-->
    <footer>
        <ul>
            <li>
                <a href="https://dotnetfoundation.org">
                    <img class="dot-net-foundation-logo" src="https://raw.githubusercontent.com/dotnet/swag/master/logo/dotnetfoundation_v4.png" alt="Supported by the .NET Foundation" />
                </a>
                Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
            </li>
        </ul>
    </footer>
</body>

<foot>
    <script type='text/javascript' src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script type='text/javascript' src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/marten/content/prism.js"></script>
    <script type="text/javascript" src="/marten/content/sidebar.js"></script>
    <script type="text/javascript" src="/marten/content/affix.js"></script>

    <script>
        $('#search').keyup(function (e) {
            if (e.keyCode == 13) {
                var search = $('#search').val();

                var url = 'https://www.google.com/#q=site:jasperfx.github.io ' + search;
                url = encodeURI(url);

                //alert(url);

                window.location.href = url;

                e.stopPropagation();
                if (e.cancelBubble != null) e.cancelBubble = true;
                return false;
            }

        });
    </script>
</foot>
</html>
